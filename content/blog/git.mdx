---
title: "GIT"
date: 2025-10-28
author: "Axel Leguero"
---
# GIT #
## Clase 1: ##

- Qué es GIT 
- GIT vs otros gestores de repositorios
- ¿Qué es Subversion o SVN?
- Conceptos básicos de GIT
- Workflow de GIT
- Para qué se usa
- Repositorios (públicos - privados, local - remoto)
- Cómo se usa
- Instalación en el SO
- Configuraciones Globales
- Crear Repositorio


# Qué es GIT #
Es un sistema de control de versiones distribuido. Guarda un repositorio central por cada proyecto y cada participante descarga una copia local del mismo en su dispositivo. 
Los repositorios permiten tener una linea de tiempo de todo lo que está sucediendo. 
Ventajas: 
- Control total de versiones
- Trabajo en conexión
- Integración con plataformas como Github

# Git vs otros gestores de repositorios #
## GitHub ##
Es una plataforma de alojamiento de código basado en Git, que permite guardar proyectos, colaborar en equipo y hacer control de versiones.
Entre sus funciones está alojar repositorios públicos y privados; control de versiones con Git; revisar código mediante Pull Requests; Integración con herramientas CI/CD; facilita la colaboración en proyectos Open Source.
## GitLab ##
También usa Git, pero ofrece una solución mas integral: Combina el control de versiones con un sistema completo de DevOps.
Entre sus funciones principales está los repositorios Git; CI/CD integrado; gestión de issues, tareas y flujos de trabajo; seguridad y despliegue automatizado; y puede instalarse en servidores propios.
## Bitbucket ##
Funciones principales repositorios Git; Integración fuerte con Jira y Trello; CI/CD con Bitbucket y Pipelines; Control de acceso y permisos avanzados; y soporte para proyectos privados gratuito.

# Que es subversion o SVN #
Se basa en un sistema de control de versiones centralizado. Existe un almacén central de
datos (el repositorio) accesible a todos los usuarios. El sistema evita que dos usuarios
puedan editar un mismo archivo al mismo tiempo.

# Conceptos básicos de GIT #
Git se basa en snapshots (instantáneas) del código en un estado determinado, que viene dado por el
autor y la fecha.
Un Commit es un conjunto de cambios guardados en el repositorio de Git y tiene un identificador SHA1
único.
Las ramas (branches) se pueden pensar como una línea de tiempo a partir de los commit. Hay siempre
como mínimo una rama principal o predefinida 

# Workflow de git #
con el comando Git add enviamos los cambios a staging, que es un estado intermedio en el que se
van almacenando los archivos a enviar en el commit. Finalmente con commit lo enviamos al
repositorio local.
Si queremos colaborar con otros, con push subimos los archivos a un repo remoto y mediante pull
podríamos traer los cambios realizados por otros en remoto hacia nuestro directorio de trabajo.

# Para que se usa #
Compartir código con otras personas.
Tener un historial de los cambios realizados en el código.
Git nos permite:
•Tener un historial de cambios
•Saber quién los hizo y cuándo
•Resolver los conflictos que surjan cuando dos o más personas modifiquen el mismo archivo (merge)

# Repositorios #
•Un repositorio es un espacio, en la nube, que tenemos asignado para poder
alojar todos los archivos de nuestro proyecto.
•Un repositorio es el lugar donde van a estar todos los commits que forman
parte del historial del proyecto.

## Repositorios Locales y Remotos ##
•GIT trabaja con un repositorio local que está en nuestro equipo, donde
iremos agregando nuestros commits.
•También trabaja con uno remoto en el cual podemos subir nuestros commits
o del cual podemos bajarnos los commits que haya subido alguien.

# Como se usa #
1. Creamos/borramos/modificamos archivos en una carpeta
asociada a un repositorio (localmente, en nuestro S.O)
2. Seleccionamos los archivos que van a ser parte de un commit.
3. Confirmamos el commit para agregarlo al repositorio.
4. Subimos los commits de nuestro repositorio local al repositorio
remoto.

# INSTALACIÓN EN EL SISTEMA OPERATIVO #
•Para poder utilizar GIT en nuestro equipo necesitamos tener instalado un cliente
de dicho sistema.
•El cliente puede tener una interfaz gráfica o puede ser accesible únicamente
mediante la línea de comandos.
•“GIT” es un cliente de GIT que nos permite acceder desde la línea de
comandos de cualquier terminal a las funcionalidades brindadas por dicho
sistema de versionado.
•También instala su propia terminal llamada Git Bash.
•Además, trae un GUI Client muy sencillo y básico.
El link a su sitio de descargas es:
https://git-scm.com/downloads

# CONFIGURACIONES GLOBALES #
Luego de haber instalado algún cliente de GIT en nuestro equipo, debemos realizar
mínimamente las siguientes dos configuraciones:
git config --list Esto te permitira ver toda la configuracion de nuestro git por consola
git config --get user.name Si solo deseamos ver el nombre de usuario configurado
git config --get user.email Si necesitamos ver el correo configurado
Para configurar hacemos lo siguiente
git config --global user.name "TU NOMBRE"
git config --global user.email "TU DIRECCION DE EMAIL«
Git config user.password Token
git config credential.username « TU EMAIL"

# Crear Repositorio #
Tenemos 2 opciones
• Si ya tenemos inicializado un repo con git init solo debemos agregar el origen
del repo remoto y pushearlo
git remote add origin https://github.com/maxdebian/bootcamp4.git
git branch -M main
git push -u origin main
• Si no tenemos creado nada y creamos solo el repo web ahí deberemos
hacer todos los pasos siguientes
echo "# gym2" >> README.md
git init git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/maxdebian/gym2.git
git push -u origin main

## Clase 2 ##

- Comandos básicos

## Comandos básicos ##
### git clone ###
git clone url_repositorio_remoto
•Permite clonarnos un repositorio remoto.
•En el caso de que el repositorio sea privado, debemos tener el correspondiente
acceso y permiso para descargarlo (debemos tener el rol de “propietario” o
formar parte de los “colaboradores”).
### git status ###
•Debe ejecutarse en una terminal situados en la raíz de un repositorio clonado
(o descargado).
•Permite saber si se realizaron cambios sobre archivos que aún no fueron
commiteados.
### git add ###
git add filename
•Debe ejecutarse en una terminal situados en la raíz de un repositorio clonado (o
descargado).
•Permite agregar uno o varios archivos al área de staging(repositorio local), para que
luego éstos sean commiteados(en un mismo commit) y subidos al repositorio remoto.
git add .
### git commit ###
git commit –m ‘mensaje’
•Debe ejecutarse en una terminal situados en la raíz de un repositorio clonado
(o descargado).
•Permite armar y guardar un commit con los archivos que se encuentran en el
área de staging(los que previamente fueron agregados con gitadd).
•Debe considerarse que un commit es un “punto de cambio del proyecto”,
situado cronológicamente.
### git push ###
git push remote branch
•Debe ejecutarse en una terminal situados en la raíz de un repositorio clonado
(o descargado).
•Permite subir los commits realizados en nuestro repositorio local al repositorio
remoto para que éstos puedan ser descargados por el resto del equipo de
trabajo.
### git pull ###
•Debe ejecutarse en una terminal situados en la raíz de un repositorio clonado
(o descargado).
•Permite descargar los cambios (commits) desde el repositorio remoto y
actualizar al instante el repositorio local para reflejar ese contenido.
### git log ###
git log
Este comando nos permite ver el histórico de commits, estando situados en la carpeta de
nuestro proyecto. Esto puede dar un listado muy largo con lo cual podemos pasar linea a
línea con enter o con las teclas “CTRL + z”
De un commit podemos ver diversas informaciones básicas como:
- Identificador del commit
- Autor
- Fecha de realización
- Mensaje enviado
Es muy útil lanzar el log en una sola línea, lo que permite que veamos más
cantidad de commits en la pantalla y facilita mucho seguir la secuencia, en vez
de tener que ver un montón de páginas de commits.
Para ello usamos el mismo comando, pero con la opción "--oneline":
git log –oneline

## Clase 3 ##

Comandos básicos
![Comandos Basicos](../../../img/git-comandos.png)

### Git log ###
 Si hacemos un git checkout HASH
 git checkout 7a9b2c3
 Esto mueve nuestro HEAD a apuntar a ese commit específico, fuera de cualquier rama. Esto se llama “detached HEAD state”.
 En este estado: Podemos revisar el proyecto tal como estaba en ese commit.
 Puedes ejecutar o compilar para verificar algo.
 Pero si haces commits en este estado, esos commits no estarán asociados a ninguna rama, y podrías perderlos si cambias de rama 
sin guardarlos.
 Git incluso te avisa con un mensaje como:
 You are in 'detached HEAD' state. You can look around, make experimental changes...
 Para dejar el HEAD estable (volver a una rama)
 git checkout main
 Esto vuelve tu HEAD al último commit de esa rama y restablece el estado normal.
 Si queremos conservar los cambios:
 Crea una nueva rama desde ese commit antes de salir:
 git checkout -b fix-temporal 
Así esos cambios quedan guardados en una rama nueva, y luego podés fusionarla más tarde.
 Si olvidaste volver a una rama y hiciste commits en “detached HEAD”:
 Podés recuperarlos:
 git branch rescue-branch hash_del_commit_que_hiciste
De esa forma no se pierden

### Descarte de cambios no commiteados ###
 Puede darse el caso que interese descartar cambios que hayamos realizado sobre ciertos 
archivos (o sobre uno en particular).
 Existen al menos tres formas de descartar cambios no commiteados
 1. Descartar cambios sobre un archivo en particular, sin guardarlos.
 2. Descartar todos los cambios, sin guardarlos.
 3. Descartar todos los cambios, guardándolos.

### GIT CHECKOUT ###
 Git checkout path
 • Permite descartar los cambios no commiteados sobre un archivo en particular, sin guardarlos.
 • Descarta los cambios sobre el archivo y mueve su versión a la que esté en el último commit del 
repositorio.
 Git checkout . 
Descarta todos los cambios no commiteados.

### GIT RESET ###
 Git reset --hard
 •Permite descartar todos los cambios no commiteados , sin guardarlos.
 • Mientras que el comando “ checkout ” descarta los cambios de un archivo en particular, “ reset 
” puede descartar masivamente.
 • Este comando, en realidad, reestablece todos nuestros archivos al último commit descargado 
desde el repositorio remoto.

### GIT STASH ###
 • Permite descartar todos los cambios no commiteados , guardándolos para poder recuperarlos 
en un futuro.
 • Mientras que el comando “ reset ” descarta los cambios definitivamente, “ stash ” los guarda 
para que podamos recuperarlos.

### RECUPERAR CAMBIOS DESCARTADOS ###
 Si descartamos cambios y los hemos guardado ( git stash ), entonces estamos en condiciones de 
poder recuperarlos.
 Para poder hacer esto, es necesario conocer los siguientes comandos

 ### GIT STASH LIST – GIT STASH SHOW – GIT STASH APPLY ###
 Git stash list
 • Permite listar todos los “puntos de restauración” que hemos generado al utilizar el comando “ 
stash ” para descartar los cambios y guardarlos.
 • Git guarda todos los cambios descartados en una pila, donde el índice 0 (cero) contiene los 
últimos cambios descartados.
 Git stash show -p “stash name”
 • Permite ver los cambios que se encuentran guardados en un stash en particular.
 Git stash apply “stash name”
 • Permite recuperar los cambios desde un stash en particular.
 • Por más que hayamos recuperado los cambios de un stash en particular, git no borrará el 
punto de restauración de la pila de cambios stasheados
 Luego de recuperar cambios stasheados , git no borrará el “punto de restauración”.
 • Para poder borrar, de forma definitiva, un punto de restauración debemos hacer uso del 
comando “ stash drop

### GIT STASH DROP ###
 Git stash drop stash-name
 • Permite eliminar un “punto de restauración” de forma definitiva.
 • Luego de ser ejecutado, la pila de cambios stasheados se reordenará.
 • Advertencia : este comando no solicita confirmación para poder ejecutarse.

### CONFLICTOS (merges) ###
 • Puede darse el caso de que estemos trabajando sobre mismo archivo en el cual que está 
trabajando otra persona.
 • Si la otra persona sube el cambio (“ pushea ”) antes que nosotros, cuando intentemos descargar 
las cosas desde el repositorio remoto (“ pullear ”) se nos generará un conflicto (“ merge)
 • Un merge se genera cuando dos o más commits contienen cambios sobre los mismos archivos, 
sobre las mismas líneas de código

• Para resolver un conflicto, es necesario quedarnos con la “porción” de código que nos interese.
 • Para ello debemos:
 • Borrar totalmente las sentencias propias y quedarnos con las sentencias del commit entrante.
 • Borrar totalmente las sentencias del commit entrante y quedarnos con las propias.
 • Hacer una combinación de sentencias (propias y entrantes)
 
 ![Lineas que indican conflicto](./img/git-conflicto.png)
 Luego de solucionar el merge , debemos commitear y pushear los cambios para que todo el 
equipo pueda visualizar el archivo actualizado.

### Git checkout ###
 Se puede regresar a commit anteriores mediante el hash del log y el checkout 
Git checkout HASH que queremos regresar
 Esto lo lleva de nuevo a la rama maestra. A menos que quieras trabajar con algunas funciones 
más avanzadas de Git, es mejor no realizar ningún cambio en tu proyecto cuando hayas 
revisado un commit anterior. Sin embargo, si eres el único que trabaja
 en un proyecto y quieres descartar todos los commit recientes y volver a un estado anterior, puede 
restablecer el proyecto a un
 commit anterior. Trabajando desde la rama maestra, ingrese lo siguiente:
 Git reset –hard hashLog
